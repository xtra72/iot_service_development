:imagesdir: ./images

= Data flow management(데이터 흐름 관리 )

IoT 서비스에서 **수집/전달/처리/저장/출력**의 단계로 나누어 데이터를 관리하는 구조는 **데이터 흐름**을 일관성 있게 유지하고, **확장성**과 **유연성**을 높이는 데 효과적입니다. 이 중에서 **전달**은 서비스 구성 요소 간 데이터를 안전하고 신속하게 전달하여 **실시간 모니터링** 및 **처리**가 가능하도록 하는 중요한 단계입니다. **Pub/Sub 메시지 전달 모델**을 활용하면 데이터를 필요로 하는 구성 요소가 구독하여 실시간으로 데이터를 수신하므로, **비동기식 통신**과 **확장성**이 용이합니다.

아래는 IoT 서비스의 구성 요소 간 데이터 **전달 단계**에서 **Pub/Sub 모델**과 **Mosquitto, RabbitMQ, Kafka** 등의 오픈 소스 소프트웨어를 중심으로 설명한 내용입니다.

---

== 1. Pub/Sub 메시지 전달 모델의 개요


**Pub/Sub**(Publish/Subscribe) 메시지 전달 모델은 **발행자(Publisher)**와 **구독자(Subscriber)**로 구성됩니다. 발행자는 특정 **토픽(Topic)**으로 메시지를 발행하고, 구독자는 해당 토픽을 구독하여 **필요한 데이터만 수신**하는 방식입니다. 이를 통해 데이터를 필요로 하는 구성 요소가 실시간으로 데이터를 받아보고, **비동기적으로 처리**할 수 있습니다.

image:pub_sub.png[]

* 출처: https://aws.amazon.com/ko/what-is/pub-sub-messaging/

=== 1.1 Pub/Sub 모델의 장점
* **확장성**: 여러 구성 요소가 동일한 데이터 소스를 구독하거나 발행할 수 있어 **확장성**이 우수합니다.
* **유연한 데이터 흐름 관리**: 특정 데이터에만 접근이 필요한 구성 요소가 해당 데이터만 구독할 수 있어 **데이터 전달 효율**이 높아집니다.
* **비동기 통신**: 데이터를 보내고 받을 때 동기화 상태가 필요하지 않아 시스템의 응답성과 유연성이 향상됩니다.

== 2. IoT 데이터 전달을 위한 오픈 소스 소프트웨어

각 소프트웨어는 **Pub/Sub 모델**을 사용하여 **발행된 데이터를 구독자에게 전달**하고, IoT 시스템의 구성 요소가 필요한 데이터에 접근할 수 있도록 지원합니다. **Mosquitto, RabbitMQ, Kafka**는 각기 다른 특성을 가지고 있으며, IoT 시스템의 요구 사항에 따라 선택할 수 있습니다.

=== 2.1 Mosquitto (MQTT Broker)

Mosquitto는 **경량의 MQTT 브로커**로, **저전력 디바이스** 및 **네트워크 대역폭**이 제한적인 환경에 적합합니다. MQTT는 **Pub/Sub 기반 메시징 프로토콜**로, 메시지를 **토픽**을 통해 전송하여 구성 요소들이 실시간으로 데이터를 구독할 수 있게 합니다.

* **특징**: 경량 프로토콜로 대역폭 절약이 가능하며, 센서 데이터 수집 및 IoT 디바이스 간 통신에 최적화.
* **적용 예시**: 환경 센서의 데이터를 수집하여 실시간 모니터링 시스템에 전송하는 데 활용. 예를 들어, **/farm1/greenhouse1/temperature** 토픽으로 온도 데이터를 발행하여 구독자가 데이터를 모니터링.

=== 2.2 RabbitMQ (AMQP Protocol Broker)

RabbitMQ는 **AMQP**(Advanced Message Queuing Protocol)를 사용하는 **메시지 브로커**로, **복잡한 라우팅 규칙**을 설정할 수 있어 IoT 시스템에서 **다양한 형태의 데이터 흐름**을 구성할 수 있습니다. **큐(queue)** 기반의 메시지 전달 방식과 **Pub/Sub 모델**을 혼합하여 사용할 수 있습니다.

* **특징**: 라우팅과 메시지 관리가 용이하여, 복잡한 데이터 흐름과 다양한 구독 조건을 지원합니다.
* **적용 예시**: 공장 내 다양한 센서 데이터를 각기 다른 구독 조건에 맞춰 전달하는 경우. 예를 들어, 특정 공정의 온도와 습도 데이터만 특정 모듈에서 구독할 수 있도록 구독 규칙을 설정.

=== 2.3 Kafka (Distributed Streaming Platform)

Kafka는 **대규모 데이터 스트리밍**을 위한 **분산 메시징 플랫폼**으로, 실시간 데이터 분석과 처리에 특화되어 있습니다. 높은 **처리량**과 **내구성**을 갖춘 **이벤트 스트리밍**을 지원하여, 많은 양의 데이터를 **실시간으로 전송**하고 처리할 수 있습니다.

* **특징**: 실시간 스트리밍 분석과 데이터 파이프라인 구축에 적합하며, 고속 데이터 처리를 위한 분산 환경을 지원.
* **적용 예시**: 스마트 시티에서 수집되는 대규모 데이터를 실시간으로 분석 시스템에 전송하여 이상 상태를 감지. 예를 들어, **/city1/traffic/vehicle_count** 토픽으로 교통량 데이터를 전송하여 실시간 분석.

== 3. IoT 데이터 전달에서의 구성 요소 역할

**collector**는 다양한 센서나 디바이스의 데이터를 수집한 후 **토픽을 설정**하여 발행하며, 각 data processing 모듈은 구독을 통해 데이터를 수신하고 처리합니다.

1. collector 역할
** 각 센서에서 수집된 데이터를 **토픽**을 기반으로 구분하여 발행.
** 예를 들어, 온도 센서에서 수집된 데이터는 **/factory1/lineA/temp_sensor/temperature**와 같이 정의된 토픽으로 MQTT 브로커(Mosquitto)로 발행.

2. Data Processing Module의 구독
** **Node-RED**: 시각화와 간단한 처리 작업을 수행할 때 사용되며, 특정 데이터만 구독하여 실시간 모니터링에 활용.
** **Telegraf**: 데이터 전처리와 집계 작업에 활용되며, 복합적인 데이터 분석이 필요한 경우 Kafka와 같은 대규모 메시지 브로커를 통해 데이터를 구독.
** **NiFi**: 복잡한 데이터 흐름을 구성할 때 RabbitMQ와 연동하여 조건에 따라 데이터를 필터링 및 변환하여 구독.

== 4. IoT 데이터 전달 구조의 장점

이처럼 **Pub/Sub 메시지 전달 모델**과 **오픈 소스 메시지 브로커**를 활용하여 IoT 데이터를 전달하면, IoT 서비스 구성 요소 간의 데이터 흐름이 **유연**하고 **확장성** 있게 유지됩니다.

* **효율적인 데이터 관리**: 특정 구성 요소가 필요로 하는 데이터만 구독함으로써 네트워크 부하를 줄이고, 데이터 전송 효율을 높임.
* **실시간 데이터 처리**: 메시지 브로커를 통해 데이터를 실시간으로 전송하여, 모니터링 및 이상 상태 감지가 가능.
* **확장성 및 유연성**: 필요에 따라 새로운 구성 요소를 쉽게 추가할 수 있으며, 기존 구성 요소에 영향을 미치지 않음.

== 5. 정리

* 이와 같은 구조는 IoT 서비스에서 수집된 데이터가 **collector**에서 **data processing** 모듈로 전달되는 동안 **일관성**과 **효율성**을 유지하여, 시스템이 안정적으로 운영될 수 있게 합니다.

== 6. 참고

=== 6.1 Message Queue vs Pub/Sub Model

Message Queue와 Pub/Sub 모델은 메시지 전달을 위해 널리 사용되는 두 가지 메시징 패턴으로, 서로 다른 특징과 사용 사례를 가지고 있습니다. 아래에서 차이점과 장단점을 상세히 설명하겠습니다.


==== 6.1.1 Message Queue

image:message_queue.png[]

* 출처: https://aws.amazon.com/ko/message-queue/

===== 6.1.1.1 작동 원리
* **Point-to-Point(P2P) 모델**로 작동합니다.
* 메시지를 생산하는 쪽(Producer)과 소비하는 쪽(Consumer)이 1:1 관계를 형성합니다.
* 메시지는 큐에 저장되며, 소비자가 메시지를 읽으면 큐에서 제거됩니다(일회성 전달).
* 하나의 메시지는 하나의 소비자만 처리합니다.

===== 6.1.1.2 특징
* **메시지 순서 보장:** 대부분의 메시지 큐는 메시지가 도착한 순서대로 처리되도록 보장합니다.
* **메시지 영속성:** 메시지는 소비자가 처리할 때까지 큐에 저장됩니다.
* **수평 확장:** 여러 소비자를 설정해 부하를 분산할 수 있습니다.

===== 6.1.1.3 장점
1. **확실한 전달:** 메시지는 소비자가 처리할 때까지 유지되므로 데이터 손실 위험이 적습니다.
2. **로드 분산:** 여러 소비자를 설정해 부하를 균등하게 분산할 수 있습니다.
3. **간단한 모델:** 특정 소비자에게만 메시지를 전달하므로 구현 및 관리가 상대적으로 단순합니다.

===== 6.1.1.4 단점
1. **소비자 수 제한:** 하나의 메시지는 하나의 소비자만 처리하므로 다수의 소비자가 같은 메시지를 동시에 처리할 수 없습니다.
2. **유연성 부족:** 다수의 소비자에게 동일한 메시지를 전달하는 데 적합하지 않습니다.
3. **확장성 한계:** 대규모 다대다 메시징 시나리오에서는 비효율적일 수 있습니다.

---

==== 6.1.2 Publish/Subscribe (Pub/Sub) 모델

===== 6.1.2.1 작동 원리
* **다대다(Broadcast) 모델**로 작동합니다.
* Producer는 특정 주제(Topic)에 메시지를 발행하며, Consumer는 해당 주제를 구독합니다.
* 메시지는 주제를 구독한 모든 소비자에게 전달됩니다.

===== 6.1.2.2 특징
* **다수 소비자 지원:** 하나의 메시지를 여러 소비자가 동시에 받을 수 있습니다.
* **비동기 처리:** 소비자는 자신의 속도에 맞게 메시지를 처리할 수 있습니다.
* **주제 기반 라우팅:** 메시지는 특정 주제에 따라 라우팅됩니다.

===== 6.1.2.3 장점
1. **확장성:** 하나의 메시지를 다수의 소비자가 동시에 처리할 수 있어 대규모 분산 시스템에 적합합니다.
2. **유연성:** 메시지를 주제별로 분류해 구독 모델을 제공하므로 다양한 소비자 요구를 충족할 수 있습니다.
3. **비동기 처리 가능:** 생산자와 소비자가 독립적으로 동작하므로 높은 처리량을 유지할 수 있습니다.

===== 6.1.2.4 단점
1. **메시지 손실 가능성:** 소비자가 메시지를 수신하지 못한 경우(오프라인) 메시지가 손실될 수 있습니다. 이를 해결하려면 추가적인 메시지 보관 메커니즘이 필요합니다.
2. **복잡성 증가:** 메시지 전달 로직과 구독 관리가 복잡할 수 있습니다.
3. **메시지 순서 보장 어려움:** 주제 구독자 간에 메시지 순서가 보장되지 않을 수 있습니다.


==== 6.1.3 비교표

[cols="1a,2a,2a"]
|===
^s| 특징 ^s| Message Queue ^s| Pub/Sub Model
^s| 전달 방식 ^| 1:1(Point-to-Point) ^| 1:다(Multi-Consumer)
^s| 메시지 소비 ^| 한 소비자가 메시지 처리 후 삭제 ^| 모든 구독자가 메시지 수신 가능
^s| 순서 보장  ^| 메시지 순서 보장이 일반적 ^| 순서 보장이 어려울 수 있음
^s| 확장성 ^| 제한적 ^| 대규모 시스템에 적합
^s| 유연성 ^| 낮음 ^| 높음
^s| 주요 사용 사례 ^| 작업 대기열(Job Queue), 백엔드 처리  ^| 실시간 알림, 이벤트 브로드캐스트
|===

---

==== 6.1.4 사용 사례

===== 6.1.4.1 Message Queue
* **작업 대기열(Job Queue):** 백엔드 작업을 분배 및 처리하는 시스템.
* **비동기 작업 처리:** 데이터 처리량이 많고, 소비자가 한 번에 하나씩 작업해야 하는 경우.

===== 6.1.4.2 Pub/Sub 모델
* **알림 시스템:** 여러 사용자 또는 장치에 동시에 메시지를 보내는 시스템.
* **실시간 이벤트 스트리밍:** 로그 모니터링, IoT 데이터 브로드캐스팅.

---

==== **결론**

* **Message Queue**는 메시지 순서를 중요시하거나 1:1 작업 처리가 필요한 경우 적합합니다.
* **Pub/Sub 모델**은 메시지의 다대다 전달 및 동시 처리가 요구되는 상황에 더 적합합니다.

선택은 애플리케이션의 요구사항(확장성, 메시지 손실 가능성, 소비자 수)에 따라 달라집니다.

---

[cols="1a,1a,1a",grid=none,frame=none]
|===
<s|link:../ch04/section_4_3.adoc[이전 섹션]
^s|link:../../README.md[목차]
>s|link:section_5_2.adoc[다음 섹션]
|===